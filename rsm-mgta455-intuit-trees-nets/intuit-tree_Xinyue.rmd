---
title: "Intuit-trees_Xinyue"
output: html_document
---

```{r r_setup, include = FALSE}
## initial settings
knitr::opts_chunk$set(
  comment = NA,
  echo = TRUE,
  error = TRUE,
  cache = FALSE,
  message = FALSE,
  dpi = 144,
  warning = FALSE
)

## width to use when printing tables etc.
options(
  width = 250,
  scipen = 100,
  max.print = 5000,
  stringsAsFactors = FALSE
)

## load radiant packages if needed
if (!exists("r_environment")) library(radiant)
```

<style>
.table {
  width: auto;
}
ul, ol {
  padding-left: 18px;
}
pre, code, pre code {
  overflow: auto;
  white-space: pre;
  word-wrap: normal;
  background-color: #ffffff;
}
</style>

## Setup

Please complete this R-markdown document with your group by working through the guidelines in `intuit-trees-nets.pdf` on Dropbox (week7/readings/). Create an HTML file with all your results and comments and push both the Rmarkdown and HTML file to GitLab when your team is done. All results MUST be reproducible (i.e., the TA and I must be able to recreate the HTML from the Rmarkdown file without changes or errors). Also, make sure the code is well commented and formatted (e.g., use styler through Addins > Style active file in Rstudio).

This is the second group assignment for MGTA 455 and you will be using git and GitLab. If two people edit the same file at the same time you could get what is called a "merge conflict". git will not decide for you who's change to accept so the team-lead will have to determine which edits to use. To avoid merge conflicts, always click "pull" in Rstudio before you start working on file. Then, when you are done, commit your changes, and push them to GitLab. Make this a habit!

If multiple people are going to work on the assignment at the same time I recommend you work on different files. You can use `source` to include R-code in your Rmarkdown document or include other R(markdown) documents into the main assignment file. 

Group work-flow tips are listed from ICT in summer are shown below:

* Pull, edit, save, stage, commit, and push
* Schedule who does what and when
* Try to avoid working simultaneously on the same file 
* If you are going to work simultaneously, do it in different files, e.g., 
    - assignment1_john.R, assignment1_susan.R, assignment1_wei.R 
    - assignment1a.R, assignment1b.R, assignment1c.R
* Use the 'source' command to bring different pieces of code together in an Rmarkdown document or in an R-code file
* Alternatively, use _child_ in Rmarkdown to include a part of a report
* For (very) big projects use 'branches' to avoid conflicts (and stay on your branch)

A graphical depiction of the group work-flow is shown below:

![](images/git-group-workflow.png)

Additional resource on the use of git are linked below:

* http://happygitwithr.com
* http://r-pkgs.had.co.nz/git.html
* http://stackoverflow.com/questions/tagged/git or just a google search
* https://try.github.io
* https://www.manning.com/books/git-in-practice
* https://github.com/GitInPractice/GitInPractice#readme


```{r}
## loading the data. Note that data must be loaded from the data/
## in the rstudio project directory
intuit75k <- readr::read_rds(file.path(radiant.data::find_dropbox(), "MGTA455-2019/data/intuit75k.rds"))
```

```{r}
install.packages("rpart.plot")
library(dplyr)
library(ggplot2)
library(caret)
library(rpart)
library(rpart.plot)
library(gbm)
library(randomForest)
library(xgboost)
library(radiant)
library(ranger)
```


```{r}
# Creating variables zip801 and zip804
intuit75k$zip801 <- ifelse(intuit75k$zip == "00801", TRUE, FALSE)
intuit75k$zip804 <- ifelse(intuit75k$zip == "00804", TRUE, FALSE)
intuit75k <- intuit75k %>%
  mutate(numords_version1 = numords * version1, last_version1 = last * version1)
## converting "zip_bins" data type to factor
intuit75k$zip_bins <- as.factor(intuit75k$zip_bins)
# Train and validation
train <- filter(intuit75k, training == 1) %>%
  select("id","res1","zip_bins","numords","dollars","last",
         "version1","owntaxprod","upgraded","zip801","zip804", "numords_version1", "last_version1")

val <- filter(intuit75k, training == 0) %>%
  select("id","res1","zip_bins","numords","dollars","last",
         "version1","owntaxprod","upgraded","zip801","zip804", "numords_version1", "last_version1")

```

```{r}
# Calculating Breakeven Response Rate
mail_cost <- 1.41
sales_margin <- 60
breakeven_response <- mail_cost / sales_margin

```
## perfprmance function
```{r}
## wave1
perf_eval_wave1 <- function(df) {
  
  cus <- nrow(df)
  perc_mail <- mean(df$mailto_wave1)
  dat <- filter(df, mailto_wave1 == TRUE)
  resp <- mean(dat$res1 == 'Yes')
  act_resp <- mean(df$res1 == 'Yes') 

  nummail <- sum(df$mailto_wave1)
  mailcost <- nummail * mail_cost

  exp_buyer <- sum(dat$res1 == 'Yes')
  act_buyer <- sum(df$res1 == 'Yes')

  exp_margin <- exp_buyer*sales_margin
  act_margin <- sum(df$res1 == 'Yes') * sales_margin

  profit <- exp_buyer *sales_margin - mailcost
  ROME <- profit / mailcost
  
  AUC <- auc(as.numeric(df$mailto_wave1), df$res1, 'Yes')
  
  prnt <- paste0("Based on our analysis, the number of customers Intuit should mail is ", format_nr(nummail, dec = 0), " that is ", format_nr(perc_mail, perc = TRUE), " of the customers.</br> The response rate for the selected customers is predicted to be ", format_nr(resp, perc = TRUE), ", or, ", format_nr(exp_buyer, dec = 0), " buyers; while the actual response rate is ", format_nr(act_resp, perc = TRUE), ", or, ", format_nr(act_buyer, dec=0), ".</br> The predicted margin is ", format_nr(exp_margin, "$", dec = 2), "; while actual margin is ", format_nr(act_margin, "$", dec=2),  ".</br> The expected profit is ", format_nr(profit, "$", dec = 0), ". The messaging cost is estimated to be ", format_nr(mailcost, "$", dec = 0), " with a ROME of ", format_nr(ROME, perc = FALSE), ".")

  data.frame(nummail, perc_mail, resp, exp_buyer, exp_margin, profit, mailcost, ROME, AUC, prnt)
}
```

```{r}
# wave2
perf_eval_wave2 <- function(df) {
  
  cus <- nrow(df)
  perc_mail <- mean(df$mailto_wave2)
  dat <- filter(df, mailto_wave2 == TRUE)
  resp <- mean(dat$res1 == 'Yes') * 0.5

  nummail <- sum(df$mailto_wave2)
  mailcost <- nummail * mail_cost

  exp_buyer <- sum(dat$res1 == 'Yes') * 0.5

  exp_margin <- exp_buyer*sales_margin

  profit <- exp_buyer *sales_margin - mailcost
  ROME <- profit / mailcost
  
  prnt <- paste0("Based on our analysis, the number of customers Intuit should mail is ", format_nr(nummail, dec = 0), " that is ", format_nr(perc_mail, perc = TRUE), " of the customers.</br> The response rate for the selected customers is predicted to be ", format_nr(resp, perc = TRUE), ", or, ", format_nr(exp_buyer, dec = 0), " buyers.</br> The predicted margin is ", format_nr(exp_margin, "$", dec = 2), ".</br> The expected profit is ", format_nr(profit, "$", dec = 0), ". The messaging cost is estimated to be ", format_nr(mailcost, "$", dec = 0), " with a ROME of ", format_nr(ROME, perc = FALSE), ".")

  data.frame(nummail, perc_mail, resp, exp_buyer, exp_margin, profit, mailcost, ROME, prnt)
}
```  

## decision tree - rpart

```{r}
set.seed(1234)
control <- rpart.control(minsplit = 20, cp = 0.0001, maxdepth =11) #
model_rpart <- rpart(
  formula = res1 ~ zip_bins +  numords + dollars + last + version1 + owntaxprod + upgraded + zip801 + zip804 + numords_version1+last_version1,
  data = train,
  method = "class",
  parms = list(split = "gini"),
  control = control)

```


```{r}
train_rp <- train
val_rp <- val
val_rp$pred_tree <- predict(model_rpart, val, type = "prob")[, "Yes"]
## profit
result <- confusion(
  dataset = val_rp,
  pred = "pred_tree",
  rvar = "res1",
  lev = "Yes",
  cost = 1.41,
  margin = 60,
  train = "All"
)
summary(result)

```

```{r}
train_rp <- train_rp %>% mutate(pred_tree = predict(model_rpart, train_rp, type = "prob")[,"Yes"],
                                mailto_wave1 = pred_tree > breakeven_response,
                                mailto_wave2 = pred_tree > breakeven_response)
val_rp <- val_rp %>% mutate( mailto_wave1 = pred_tree > breakeven_response,
                            mailto_wave2 = pred_tree*0.5 > breakeven_response)
```

```{r}
perf_eval_wave1(train_rp)
perf_eval_wave2(train_rp)
perf_eval_wave1(val_rp)
perf_eval_wave2(val_rp)

```

## Random Forest

```{r}
train_rf <- train 
test_rf <- val
```



```{r}

# test mtry from 1 to 5, num.trees from 200 to 600, sample.fraction from 0.1 to 0.8, min.node.size from 10 to 500
# choose mtry = 3, num.trees = 550, sample.fraction = 0.7, min.node,size = 250



# rf1 <- ranger(res1 ~ .- id - numords_version1-last_version1 , probability = TRUE,
#              data = train, num.trees = 550,
#             mtry = 3, respect.unordered.factors = "order", seed = 1234,
#              sample.fraction = 0.6,
#              min.node.size = 250)


# rf2 <- ranger(res1 ~ .- id -numords_version1-last_version1, probability = TRUE,
#              data = train, num.trees = 500,
#              mtry = 3, respect.unordered.factors = "order", seed = 1234, sample.fraction = 0.6,
#              min.node.size = 250)

rf3 <- ranger(res1 ~ .- id - numords_version1-last_version1 , probability = TRUE,
              data = train, num.trees = 502,
              mtry = 3, respect.unordered.factors = "order", seed = 1234,
              sample.fraction = 0.6,
              min.node.size = 120)
# predict pred_rf1 for model rf1
#pred_rf1 <- predict(rf1, test_rf)
#test_rf$pred_rf1 <- pred_rf1$predictions[, 1]

#pred_rf2 <- predict(rf2, test_rf)
#test_rf$pred_rf2 <- pred_rf2$predictions[, 1]

pred_rf3 <- predict(rf3, test_rf)
test_rf$pred_rf3 <- pred_rf3$predictions[, 1]

# evaluate model 
result <- confusion(
  dataset = test_rf,
  pred = c( "pred_rf3"),
  rvar = "res1",
  lev = "Yes",
  cost = 1.41,
  margin = 60,
  train = "All"
)
summary(result) 

```

```{r}

#test_rf1 <- test_rf %>% mutate( mailto_wave1 = pred_rf1 > breakeven_response,
#                             mailto_wave2 = pred_rf1*0.5 > breakeven_response)
#test_rf2 <- test_rf %>% mutate( mailto_wave1 = pred_rf2 > breakeven_response,
#                             mailto_wave2= pred_rf2*0.5 > breakeven_response)
test_rf3 <- test_rf %>% mutate( mailto_wave1 = pred_rf3 > breakeven_response,
                             mailto_wave2 = pred_rf3*0.5 > breakeven_response)
```

```{r}
#perf_eval_wave1(test_rf1)
#perf_eval_wave1(test_rf2)
perf_eval_wave1(test_rf3)
#perf_eval_wave2(test_rf1)
#perf_eval_wave2(test_rf2)
perf_eval_wave2(test_rf3)
```

```{r include=FALSE}
## For Scaled Profit
perf_eval <- function(df) {
  total_cus <- 801821
  resp_wave1 <- 38487
  unresp <- total_cus - resp_wave1

  dat <- filter(df, mailto_wave2 == TRUE)
  resp <- mean(dat$res1 == 'Yes') * 0.5
  perc_nummail <- sum(df$mailto_wave2) / nrow(df)
  scaled_mail <- perc_nummail * unresp
  mailcost <- scaled_mail * 1.41

  scaled_profit <- unresp*perc_nummail* resp * 60 - mailcost
  scaled_profit
}
  
```

```{r}
perf_eval(test_rf3)

```
