---
title: "intuit2_zichen"
author: "Zichen_Huang"
date: "2/16/2019"
output: html_document
---

```{r r_setup, include = FALSE}
## initial settings
knitr::opts_chunk$set(
  comment = NA,
  echo = TRUE,
  error = TRUE,
  cache = FALSE,
  message = FALSE,
  dpi = 144,
  warning = FALSE
)

## width to use when printing tables etc.
options(
  width = 250,
  scipen = 100,
  max.print = 5000,
  stringsAsFactors = FALSE
)

## load radiant packages if needed
if (!exists("r_environment")) library(radiant)
```

<style>
.table {
  width: auto;
}
ul, ol {
  padding-left: 18px;
}
pre, code, pre code {
  overflow: auto;
  white-space: pre;
  word-wrap: normal;
  background-color: #ffffff;
}
</style>


## Preperation
```{r}
library(tidyverse)
library(randomForest)
library(xgboost)

intuit75k <- readr::read_rds(file.path(radiant.data::find_dropbox(), "MGTA455-2019/data/intuit75k.rds"))
```


## Create variables
```{r}
intuit75k <- intuit75k %>% mutate(zip_fac = factor(zip_bins))

intuit75k <- intuit75k %>% 
  mutate(state = substr(zip, 1, 3),
         VI = ifelse(substr(zip, 1, 3) == '008', TRUE, FALSE),
         zip801 = ifelse(substr(zip, 1, 5) == '00801', TRUE, FALSE),
         zip804 = ifelse(substr(zip, 1, 5) == '00804', TRUE, FALSE),
         zip820 = ifelse(substr(zip, 1, 5) == '00820', TRUE, FALSE))

intuit75k <- intuit75k %>% mutate(numords_version1 = numords * version1,
                                  last_version1 = last * version1)
```


```{r}
intuit75k %>%
  group_by(zip) %>%
  summarize(zip_resp = mean(res1 == "Yes"), count = n()) %>%
  arrange(desc(zip_resp)) 
```


```{r}
intuit75k %>%
  filter(VI == TRUE) %>%
  group_by(zip) %>%
  summarize(VI_resp = mean(res1 == "Yes"), count = n()) %>%
  arrange(desc(VI_resp)) 
```


## Split the dataset into train and valid
```{r}
train <-  intuit75k %>% filter(training == 1)
val <-  intuit75k %>% filter(training == 0)
```


## Calculate breakeven response rate
```{r}
mail_cost <- 1.41
sales_margin <- 60
breakeven <- mail_cost/sales_margin
```


## Build performance functions
```{r include=FALSE}
## wave1
perf_eval_wave1 <- function(df) {
  
  cus <- nrow(df)
  perc_mail <- mean(df$mailto_wave1)
  dat <- filter(df, mailto_wave1 == TRUE)
  resp <- mean(dat$res1 == 'Yes')
  act_resp <- mean(df$res1 == 'Yes') 

  nummail <- sum(df$mailto_wave1)
  mailcost <- nummail * mail_cost

  exp_buyer <- sum(dat$res1 == 'Yes')
  act_buyer <- sum(df$res1 == 'Yes')

  exp_margin <- exp_buyer*sales_margin
  act_margin <- sum(df$res1 == 'Yes') * sales_margin

  profit <- exp_buyer *sales_margin - mailcost
  ROME <- profit / mailcost
  
  AUC <- auc(as.numeric(df$mailto_wave1), df$res1, 'Yes')
  
  prnt <- paste0("Based on our analysis, the number of customers Intuit should mail is ", format_nr(nummail, dec = 0), " that is ", format_nr(perc_mail, perc = TRUE), " of the customers.</br> The response rate for the selected customers is predicted to be ", format_nr(resp, perc = TRUE), ", or, ", format_nr(exp_buyer, dec = 0), " buyers; while the actual response rate is ", format_nr(act_resp, perc = TRUE), ", or, ", format_nr(act_buyer, dec=0), ".</br> The predicted margin is ", format_nr(exp_margin, "$", dec = 2), "; while actual margin is ", format_nr(act_margin, "$", dec=2),  ".</br> The expected profit is ", format_nr(profit, "$", dec = 0), ". The messaging cost is estimated to be ", format_nr(mailcost, "$", dec = 0), " with a ROME of ", format_nr(ROME, perc = FALSE), ".")

  data.frame(nummail, perc_mail, resp, exp_buyer, exp_margin, profit, mailcost, ROME, AUC, prnt)
}


## wave2
perf_eval_wave2 <- function(df) {
  
  cus <- nrow(df)
  perc_mail <- mean(df$mailto_wave2)
  dat <- filter(df, mailto_wave2 == TRUE)
  resp <- mean(dat$res1 == 'Yes') * 0.5

  nummail <- sum(df$mailto_wave2)
  mailcost <- nummail * mail_cost

  exp_buyer <- sum(dat$res1 == 'Yes') * 0.5

  exp_margin <- exp_buyer*sales_margin

  profit <- exp_buyer *sales_margin - mailcost
  ROME <- profit / mailcost
  
  prnt <- paste0("Based on our analysis, the number of customers Intuit should mail is ", format_nr(nummail, dec = 0), " that is ", format_nr(perc_mail, perc = TRUE), " of the customers.</br> The response rate for the selected customers is predicted to be ", format_nr(resp, perc = TRUE), ", or, ", format_nr(exp_buyer, dec = 0), " buyers.</br> The predicted margin is ", format_nr(exp_margin, "$", dec = 2), ".</br> The expected profit is ", format_nr(profit, "$", dec = 0), ". The messaging cost is estimated to be ", format_nr(mailcost, "$", dec = 0), " with a ROME of ", format_nr(ROME, perc = FALSE), ".")

  data.frame(nummail, perc_mail, resp, exp_buyer, exp_margin, profit, mailcost, ROME, prnt)
}


## Scaled Profit
perf_eval <- function(df) {
  total_cus <- 801821
  resp_wave1 <- 38487
  unresp <- total_cus - resp_wave1

  dat <- filter(df, mailto_wave2 == TRUE)
  resp <- mean(dat$res1 == 'Yes') * 0.5
  perc_nummail <- sum(df$mailto_wave2) / nrow(df)
  scaled_mail <- perc_nummail * unresp
  mailcost <- scaled_mail * 1.41

  scaled_profit <- unresp*perc_nummail* resp * 60 - mailcost
  scaled_profit
}
  
```


## Approach 1: Neural Network
```{r}
train_nn <- train
val_nn <- val
```

```{r}
result <- nn(
  train_nn,
  rvar = "res1",
  evar = c("zip_fac","numords", "dollars", "last", "version1", "owntaxprod", "upgraded", "zip801", "zip804"),
  lev = "Yes",
  size = 2,
  decay = 1
)
summary(result)

pred_train <- predict(result, pred_data = train_nn)
pred_val <- predict(result, pred_data = val_nn)
```

```{r}
train_nn <- train_nn %>% mutate(purch_prob = pred_train$Prediction,
                                mailto_wave1 = purch_prob > breakeven,
                                mailto_wave2 = purch_prob*0.5 > breakeven)

val_nn <- val_nn %>% mutate(purch_prob = pred_val$Prediction,
                            mailto_wave1 = purch_prob > breakeven,
                            mailto_wave2 = purch_prob*0.5 > breakeven)
```

```{r}
perf_eval_wave1(train_nn)
perf_eval_wave1(val_nn)
perf_eval_wave2(train_nn)
perf_eval_wave2(val_nn)

perf_eval(val_nn)
```


## Approach 2: Random Forest
```{r}
train_rf <- train
val_rf <- val
```

```{r}
fit_train <- randomForest(res1 ~ zip_fac + numords + dollars + last  + version1 + owntaxprod + upgraded + zip801 + zip804, data = train_rf, ntree = 100)

pred_train <- predict(fit_train, pred_data = train_rf, type = "prob")
```

```{r}
fit_val <- randomForest(res1 ~ zip_fac + numords + dollars + last  + version1 + owntaxprod + upgraded + zip801 + zip804, data = val_rf, ntree = 100)

pred_val <- predict(fit_val, pred_data = val_rf, type = "prob")
```

```{r}
train_rf <- train_rf %>% mutate(purch_prob = pred_train[ ,1],
                                mailto_wave1 = purch_prob > breakeven,
                                mailto_wave2 = purch_prob*0.5 > breakeven)

val_rf <- val_rf %>% mutate(purch_prob = pred_val[ ,1],
                            mailto_wave1 = purch_prob > breakeven,
                            mailto_wave2 = purch_prob*0.5 > breakeven)
```

```{r}
perf_eval_wave1(train_rf)
perf_eval_wave1(val_rf)
perf_eval_wave2(train_rf)
perf_eval_wave2(val_rf)

perf_eval(val_rf)
```


## Approach 3: Boosted Decision Tree
```{r}
train_xgb <- train
val_xgb <- val
```

```{r}
train_label <- ifelse(train_xgb$res1 == "Yes", TRUE, FALSE)
val_label <- ifelse(val_xgb$res1 == "Yes", TRUE, FALSE)

train_data <- select(train, c("zip_fac","numords", "dollars", "last", "version1", "owntaxprod", "upgraded", "zip801", "zip804"))

val_data <- select(val, c("zip_fac","numords", "dollars", "last", "version1", "owntaxprod", "upgraded", "zip801", "zip804"))

train_data <- data.matrix(train_data)
val_data <- data.matrix(val_data)

dtrain <- xgb.DMatrix(data = train_data, label= train_label)
dval <- xgb.DMatrix(data = val_data, label = val_label)

model <- xgboost(data = dtrain, 
                 nround = 35,   # maximum number of boosting iterations
                 objective = "binary:logistic", gamma = 5) 


pred_train <- predict(model, dtrain)
pred_val <- predict(model, dval)
```

```{r}
train_xgb <- train_xgb %>% mutate(purch_prob = pred_train,
                                  mailto_wave1 = purch_prob > breakeven,
                                  mailto_wave2 = purch_prob*0.5 > breakeven)

val_xgb <- val_xgb %>% mutate(purch_prob = pred_val,
                              mailto_wave1 = purch_prob > breakeven,
                              mailto_wave2 = purch_prob*0.5 > breakeven)
```

```{r}
perf_eval_wave1(train_xgb)
perf_eval_wave1(val_xgb)
perf_eval_wave2(train_xgb)
perf_eval_wave2(val_xgb)

perf_eval(val_xgb)
```

